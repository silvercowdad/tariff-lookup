// ===================================================================
// 수정된 calculateTariff 함수 (HTML의 <script> 섹션에 교체)
// ===================================================================

function calculateTariff(hsInput, country, usmcaCompliant) {
  const code10 = hs10(hsInput);
  const flags = getHsFlags(code10);
  const description = getProductDescription(code10);

  const ftaInfo = getFTACountry(country);
  const hasFta = !!ftaInfo;
  const recipRate = getReciprocalRate(country);
  const mfnRate = getMFNRate(code10);

  let tariffItems = [];
  let warnings = [];
  let exemptions = [];
  let totalRate = 0;
  let ftaStatusText = hasFta ? ftaInfo.fta : "No FTA";

  // =================================================================
  // STEP 1: FTA Base Treatment
  // =================================================================

  let waiveAll = false;
  let treatAsNoFta = false;

  // CASE A: USMCA (Conditional FTA)
  if (ftaInfo && ftaInfo.type === "conditional") {
    if (usmcaCompliant) {
      // Compliant -> 0% base
      tariffItems.push({
        name: `${ftaInfo.fta} - Duty Free`,
        rate: 0,
        tag: "fta",
        description: "Certificate of Origin: Rules of Origin met",
        source: ftaInfo.fta
      });

      if (ftaInfo.waiveAllWhenCompliant) {
        waiveAll = true;
        exemptions.push(`✅ ${ftaInfo.fta}: All measures WAIVED (compliant)`);
      } else {
        exemptions.push(`✅ ${ftaInfo.fta}: Base duty-free (compliant)`);
      }
    } else {
      // NOT compliant -> treat as no FTA
      treatAsNoFta = true;
      warnings.push(`⚠️ ${ftaInfo.fta} Certificate of Origin required for 0% rate. Without it, MFN + measures apply.`);
    }
  }

  // CASE B: KORUS FTA (Minimum 15%)
  else if (ftaInfo && ftaInfo.type === "minimum") {
    const minRate = Number(ftaInfo.minRate || 0);
    const base = Math.max(0, mfnRate, minRate);
    
    tariffItems.push({
      name: `${ftaInfo.fta} Minimum Rate`,
      rate: base,
      tag: "ieepa",
      description: `MAX(FTA 0%, MFN ${(mfnRate*100).toFixed(1)}%, Min ${(minRate*100).toFixed(1)}%) = ${(base*100).toFixed(1)}%`,
      source: "ftaMinimum"
    });
    totalRate += base;
    
    warnings.push(`⚠️ ${ftaInfo.fta}: Minimum ${(minRate*100).toFixed(1)}% rate applies (was 0% before July 2025)`);
  }

  // CASE C: Standard FTA (0% duty-free)
  else if (ftaInfo && ftaInfo.type === "standard") {
    tariffItems.push({
      name: `${ftaInfo.fta} - Duty Free`,
      rate: 0,
      tag: "fta",
      description: ftaInfo.description || "0% duty-free",
      source: ftaInfo.fta
    });
    exemptions.push(`✅ ${ftaInfo.fta}: All measures WAIVED (0% duty-free treatment)`);
    waiveAll = true;
  }

  // CASE D: No FTA
  else {
    treatAsNoFta = true;
  }

  // =================================================================
  // STEP 2: Apply Measures (if not waiveAll)
  // =================================================================

  if (!waiveAll) {
    const ctx = {
      hs10: code10,
      country,
      flags,
      hasFta: hasFta && !treatAsNoFta,
      mfnRate,
      recipRate
    };

    const measures = Array.isArray(RULES.measures) ? RULES.measures : [];

    for (const m of measures) {
      // BASE measure (MFN)
      if (m.kind === "base") {
        if (treatAsNoFta) {
          const r = measureRate(m, ctx);
          tariffItems.push({
            name: m.name,
            rate: r,
            tag: m.tag || "mfn",
            description: m.description || `From rules: ${(r*100).toFixed(1)}%`,
            source: m.id
          });
          totalRate += r;
        }
        continue;
      }

      // ADDITIVE measures
      if (m.kind === "additive") {
        // Check appliesWhen conditions
        if (!appliesWhen(m, ctx)) continue;

        const r = measureRate(m, ctx);
        if (r <= 0) continue;

        tariffItems.push({
          name: m.name,
          rate: r,
          tag: m.tag || "ieepa",
          description: m.description || "Applied per rules engine",
          source: m.id
        });
        totalRate += r;
      }
    }

    // =================================================================
    // STEP 3: Apply Waivers
    // =================================================================

    const presentIds = new Set(tariffItems.map(x => x.source).filter(Boolean));
    const waivers = Array.isArray(RULES.waivers) ? RULES.waivers : [];

    for (const w of waivers) {
      if (!presentIds.has(w.whenMeasureApplied)) continue;
      
      for (const wid of (w.waiveMeasures || [])) {
        const before = tariffItems.length;
        tariffItems = tariffItems.filter(x => x.source !== wid);
        const after = tariffItems.length;
        
        if (before !== after && w.note) {
          exemptions.push(`✅ ${w.note}`);
        }
      }
    }

    // Recompute total
    totalRate = tariffItems.reduce((sum, x) => sum + (Number(x.rate) || 0), 0);
  }

  return {
    hsCode10: code10,
    description,
    countryCode: country,
    ftaStatusText,
    tariffItems,
    totalRate,
    warnings,
    exemptions
  };
}

// Helper: Check if measure applies
function appliesWhen(measure, ctx) {
  const w = measure.appliesWhen || {};
  
  // Check countries
  if (w.countries && Array.isArray(w.countries) && !w.countries.includes(ctx.country)) {
    return false;
  }
  
  // Check noFta
  if (w.noFta === true && ctx.hasFta === true) {
    return false;
  }
  
  // Check flagsAll
  if (w.flagsAll && Array.isArray(w.flagsAll)) {
    for (const f of w.flagsAll) {
      if (!ctx.flags[f]) return false;
    }
  }
  
  // Check flagsAny
  if (w.flagsAny && Array.isArray(w.flagsAny)) {
    let ok = false;
    for (const f of w.flagsAny) {
      if (ctx.flags[f]) ok = true;
    }
    if (!ok) return false;
  }
  
  return true;
}

// Helper: Get measure rate
function measureRate(measure, ctx) {
  if (typeof measure.rate === "number") return measure.rate;
  if (measure.rateSource === "mfn") return ctx.mfnRate;
  if (measure.rateSource === "reciprocal") return ctx.recipRate;
  return 0;
}
